[{"title":"分享几道题目","url":"https://birdy-c.github.io/2018/11/15/杂/趣味题/","content":"<p>室友策划的笔试题<br>觉得非常有意思，分享一下</p>\n<a id=\"more\"></a>\n<h1 id=\"I\"><a href=\"#I\" class=\"headerlink\" title=\"I\"></a><a href=\"https://zh.wikipedia.org/wiki/%E6%B5%B7%E7%9B%97%E5%8D%9A%E5%BC%88\" target=\"_blank\" rel=\"noopener\">I</a></h1><p>有五个理性的海盗，A, B, C, D和E，找到了100个金币，需要想办法分配金币。</p>\n<p>海盗们有严格的等级制度：A比B职位高，B比C高，C比D高，D比E高。</p>\n<p>海盗世界的分配原则是：等级最高的海盗提出一种分配方案。所有的海盗投票决定是否接受分配，包括提议人。并且在票数相同的情况下，提议人有决定权。如果提议通过，那么海盗们按照提议分配金币。如果没有通过，那么提议人将被扔出船外，然后由下一个最高职位的海盗提出新的分配方案。</p>\n<h1 id=\"II\"><a href=\"#II\" class=\"headerlink\" title=\"II\"></a><a href=\"http://www.tuilixy.net/thread-68761-1-1.html\" target=\"_blank\" rel=\"noopener\">II</a></h1><p>有个村落住了19个聪明绝顶的巫婆和1个漂亮的公主. 每个巫婆都知道谁吃了公主便能变成为公主. 而每个巫婆都非常渴望拥有公主的美貌. 但他们担心的是如果巫婆变成了公主, 他变会失去了法术, 随时会被其他巫婆吃掉. 究竟那个公主会不会被吃掉?</p>\n<h1 id=\"III\"><a href=\"#III\" class=\"headerlink\" title=\"III\"></a><a href=\"https://blog.csdn.net/gao1440156051/article/details/51718771\" target=\"_blank\" rel=\"noopener\">III</a></h1><p>山上有五个山洞排成一行，编号从1到5。有个狐狸，它第一天藏在某个山洞中，从第二天开始，每天可以逃到前一天所在山洞相邻的山洞中，但逃到哪一个是随机的（当然如果狐狸当前在1号山洞那么它第二天只能去2号洞了，5号也类似）。有个猎人，他每天只能搜寻一个山洞，如果狐狸当天在他搜寻的山洞中就被逮到了。问猎人是否有必定能抓住狐狸的策略？</p>\n","categories":["杂文"],"tags":["杂记"]},{"title":"assignment4[Shadows, Reflection & Refraction]","url":"https://birdy-c.github.io/2018/07/16/MOOC/MIT-6-837/assignment4/","content":"<p>在之前的项目中加入二次光照——现在Ray Caster就算升级为Ray Tracer了！<br>这次实验完成之后模型里就有简单的阴影、反射和折射了。</p>\n<a id=\"more\"></a>\n<h1 id=\"assignment-4\"><a href=\"#assignment-4\" class=\"headerlink\" title=\"assignment 4\"></a>assignment 4</h1><h2 id=\"Log\"><a href=\"#Log\" class=\"headerlink\" title=\"Log\"></a>Log</h2><p>感觉这次的题特别多——</p>\n<p>weight 那个0.01是干啥的——做到最后也没有加……weight确实应该是有用的，如果考虑到光线衰减的话。比方说在镜子里看到的点光源，衰减应该要考虑到折射前的路程。但是感觉这样算又非常的复杂，因为衰减不是线性的没法简单的通过两段的叠加实现。<br>然后这个值最后还是没有用（……）</p>\n<p>增加transparent_shadows。这个值相当于一个mask，之前是如果有遇到物体就设置为0，不遇到物体是1，然后乘以该光源的颜色。现在变成在0-1之间变换，由引向光源的射线穿透物体的透明属性决定。<br>输出了一下在这次的数据中T的差不多在，0.8以内。<br>觉得算power太麻烦了直接定为线性衰减。T为1的时候，mask和该物体的透明颜色一样。然后看起来和图蛮像的……<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/4/output4_06f_trans.png\" alt=\"my result\"> </p>\n<p>比较丧的一点是，那个钻石的例子我到最后也没有调对，不知道哪里出了问题……或许等做后面的题目了就知道了……摊手<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/4/output4_14fr.png\" alt=\"example\"><br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/4/output4_14fw.png\" alt=\"my result\"><br>一个问题是过亮，一个问题是偏红色。<br>如果在发出的射线不和任何物体相交的时候，返回0，那么这里的钻石不会过量，但是前面的一个例子能明显的感觉到不对。<br>然后偏红色那个问题，我脑补了一下觉得蛮对的……</p>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>这里一边重新介绍了一下光栅化的方法。包括线和圆，以及确定线段围成的封闭图形。<br>颜色的插值使用重心坐标系。<br>可见性检测的方法——光线投射、画家算法、Z Buffer。Z Buffer 常取倒数。</p>\n<p>提了软影，反走样，Glossy Reflection（有多条反射光线），运动模糊，景深。<br>提到了各种各样的加速结构。包围盒，空间网格化（固定网格，自适应网格（四/八叉树），BVH）。<br>最后提到了把变换合并。</p>\n","categories":["Tech","MIT-6-837"],"tags":["CG"]},{"title":"assignment3 [ OpenGL & Phong Shading]","url":"https://birdy-c.github.io/2018/07/15/MOOC/MIT-6-837/assignment3/","content":"<p>在之前的项目中加入OpenGL API来实现场景交互（相机相应鼠标事件）。<br>实现Phong model。</p>\n<a id=\"more\"></a>\n<h1 id=\"assignment-3\"><a href=\"#assignment-3\" class=\"headerlink\" title=\"assignment 3\"></a>assignment 3</h1><p>这次还好吧比较常规……可能最麻烦的是配OpenGL？<br>依然是固定管线……想尝试一下可编程管线……<br>不过这个assignment里，最主要的不是OpenGL的实现。OpenGL只是提供一个交互，以及可以比较一下判断Phong Shading有没有写对。</p>\n<h2 id=\"Log\"><a href=\"#Log\" class=\"headerlink\" title=\"Log\"></a>Log</h2><p>吐槽一下camera_additions.txt这个文档为啥没有换行哇……<br>环境光的材质和漫射光的材质一样。如果计算shader的时候要直接返回颜色的话，还要多传入一个环境光的参数。<br>哦然后反正一开始的问题是配OpenGL……glut.h 与stdlib.h中的exit()重定义问题之类的。<br>文件打不开可以先用fprintf(stderr, “%s \\n”,strerror(errno));检查路径。<br>还有这个作业确实有点早……OpenGL居然有不自带画球方法的时候（惊了）<br>还有就是法线方向了、一开始以为正方体显示的时候几个全黑的面是法线设置反了，后来想了想鼠标动的是相机位置所以对于背向水平入射光的方向是一直保持黑色的。<br>还有我一开始输出的图像是倒的……之前写的时候重新计算up有问题。<br>PhongMaterial::Shade这个函数不需要计入环境光，因为可能有多盏灯啊环境光算一次就够了！<br>可以设置glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, zero);来单独测试每个光线。</p>\n<p>一开始我写错Phong的种类了，写了原始的形式。normal会比Blinn-Torrance要暗……其他也没啥感觉……</p>\n<p>最后不知道什么是高光修正？</p>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>这一次的课件是从分析Ray Casting / Tracing 的优缺点出发，引出了Rendering Pipline。<br>介绍了渲染管线的整个流程之后，重点介绍了Clipping和Scan Conversion的一些相关算法。 </p>\n<p>Ray Casting / Tracing 的优缺点<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/3/0.png\" alt=\"\"> </p>\n<p>渲染管线介绍<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/3/1.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/3/2.png\" alt=\"\"> </p>\n<p>线段的裁剪，比如Outcodes.<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/3/3.png\" alt=\"\"><br> Polygon clipping，主要就是Walking rules。<br>基本的光栅化，比如bresenham’s algorithm</p>\n<p>以及一些反走样的介绍。</p>\n","categories":["Tech","MIT-6-837"],"tags":["CG"]},{"title":"assignment2 [Transformations & Additional Primitives]","url":"https://birdy-c.github.io/2018/05/07/MOOC/MIT-6-837/assignment2/","content":"<p>加入平面和三角形，加入放射变换，加入透视相机。<br>对于放射变换的法线可视化。<br>以及漫反射光照。</p>\n<a id=\"more\"></a>\n<h1 id=\"assignment-2\"><a href=\"#assignment-2\" class=\"headerlink\" title=\"assignment 2\"></a>assignment 2</h1><p>我觉得涉及的知识点都不难但是一个线代不好的人硬生生写的快炸毛了……<br>一开始觉得变换都写好了应该不难。但是后面，变换写错之后总是跑到屏幕外面……面对空荡荡的图不知道如何debug……<br>然后调出来上一个assignment的很多个问题。  </p>\n<h2 id=\"BUG日志\"><a href=\"#BUG日志\" class=\"headerlink\" title=\"BUG日志\"></a>BUG日志</h2><ol>\n<li>鱼眼镜头的话插值是对角度进行插值，而正常的透视镜头需要对投影平面上的点。 </li>\n<li>透视相机的生成我可能大概或许还是写错了……<br>一开始觉得非常的不可理喻（因为那个角度很奇怪），后来发现可能就是比较方便测量吧。</li>\n<li>raytracer -input scene2_05_inside_sphere.txt -size 200 200 -output output2_05_no_back.tga<br>这个测试数据后面生成的应该是有环境光的那个漫反射的颜色的吧，根据之前对$c_{ambient} $的定义来看  </li>\n<li>然后还是上面那个图，要么是深度的定义出问题了要么是透视相机的问题，最后的深度图不是非常符合。</li>\n<li>平面的法线正负无法确定，用隐式定义的话根本看不出法线啊喂……  </li>\n<li>然后是三角形正反面的确定，这里是按照顺时针为正。  </li>\n<li>最后是求变换后的矩阵的法向量，如果用齐次坐标的话好似无法确定方向？求出来的法线好几次出现相反的情况。然后最后结果是直接舍弃了第四维……不知道算其他的东西的时候会不会出错</li>\n</ol>\n<p>综上所述一堆bug……  </p>\n<h3 id=\"实现内容\"><a href=\"#实现内容\" class=\"headerlink\" title=\"实现内容\"></a>实现内容</h3><p>实现了一下射线和平面求交以及射线和三角形求交，用的是上次那篇笔记里的方法。<br>一个很重要的是Normal Transformation，法线在仿射空间的变换和正常的不一样。这个例程确实解决了我对Transformation的理解上的一些坎。<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/2/2.png\" alt=\"\">  </p>\n<p>用齐次坐标表示向量和点之后在计算上有神奇的统一性。  </p>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>课件的模型除了仿射变换之外，还涉及了大量的光照模型（而在这次的程序里还只实现到漫反射光）<br>已经讲到了BRDF，讲到镜面反射和折射的原理。</p>\n<h3 id=\"变换\"><a href=\"#变换\" class=\"headerlink\" title=\"变换\"></a>变换</h3><p><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/2/1.png\" alt=\"\">  </p>\n<h3 id=\"镜面反射\"><a href=\"#镜面反射\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h3><p>分为Phong和Blinn-Torrance。<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/2/3.png\" alt=\"\"><br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/2/4.png\" alt=\"\">  </p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>Anisotropic BRDFs，Off-specular &amp; Retro-reflection</p>\n<h3 id=\"增加阴影\"><a href=\"#增加阴影\" class=\"headerlink\" title=\"增加阴影\"></a>增加阴影</h3><p>这里是用光线跟踪计算的<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/2/5.png\" alt=\"\"><br>缺陷：入射光肯定不是只有一条。</p>\n","categories":["Tech","MIT-6-837"],"tags":["CG"]},{"title":"assignment1 [Ray Casting]","url":"https://birdy-c.github.io/2018/04/22/MOOC/MIT-6-837/assignment1/","content":"<p>很简单的球的Ray Casting。<br>是一个大的项目的基础部分，所以起整体的框架起了很久。<br>感觉结构清楚的代码看起来很舒服。  </p>\n<a id=\"more\"></a>\n<h1 id=\"assignment-1\"><a href=\"#assignment-1\" class=\"headerlink\" title=\"assignment 1\"></a>assignment 1</h1><p>从这个项目来说涉及的知识点不多，Ray Casting和圆与射线相交的检测。<br>但是课件上的点还是蛮多的……</p>\n<p>这个作业主要花时间的是把C++快忘光的以及基本自己没怎么实现过的部分部分重新熟悉了一下，还有就是目测后面的代码会在这个的基础上进一步构造所以感觉会比较复杂。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"Ray-Casting\"><a href=\"#Ray-Casting\" class=\"headerlink\" title=\"Ray Casting\"></a>Ray Casting</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For every pixel</span><br><span class=\"line\">\tConstruct a ray from the eye</span><br><span class=\"line\">\tFor every object in the scene</span><br><span class=\"line\">\t\tFind intersection with the ray</span><br><span class=\"line\">\t\tKeep if closest</span><br><span class=\"line\">\tShade depending on light and normal vector</span><br></pre></td></tr></table></figure>\n<h3 id=\"补\"><a href=\"#补\" class=\"headerlink\" title=\"补\"></a>补</h3><p>写assignment2的时候觉得这个作业简直是在写BUGS……<br>距离判断有问题，相机的size的精度有问题……<br>有时间再补吧orz  </p>\n<h2 id=\"一些模型\"><a href=\"#一些模型\" class=\"headerlink\" title=\"一些模型\"></a>一些模型</h2><h3 id=\"光线的显式定义\"><a href=\"#光线的显式定义\" class=\"headerlink\" title=\"光线的显式定义\"></a>光线的显式定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P(t) = R_0 + t*R_d</span><br></pre></td></tr></table></figure>\n<h3 id=\"平面的隐式定义\"><a href=\"#平面的隐式定义\" class=\"headerlink\" title=\"平面的隐式定义\"></a>平面的隐式定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">H(P) = Ax+By+Cz  </span><br><span class=\"line\"></span><br><span class=\"line\">=nP+D=0</span><br></pre></td></tr></table></figure>\n<h4 id=\"平面与光线求交\"><a href=\"#平面与光线求交\" class=\"headerlink\" title=\"平面与光线求交\"></a>平面与光线求交</h4><p><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/1/1.png\" alt=\"\">  </p>\n<p><a href=\"https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection</a></p>\n<h3 id=\"球面的隐式定义\"><a href=\"#球面的隐式定义\" class=\"headerlink\" title=\"球面的隐式定义\"></a>球面的隐式定义</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">H(P) = P*P-r^2 = 0</span><br></pre></td></tr></table></figure>\n<p>这里中点在坐标轴原点  </p>\n<p>需要考虑到视点是否在球面内</p>\n<h4 id=\"代数求交\"><a href=\"#代数求交\" class=\"headerlink\" title=\"代数求交\"></a>代数求交</h4><p><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/1/2.png\" alt=\"\"></p>\n<h4 id=\"几何求交以及两种方法比较\"><a href=\"#几何求交以及两种方法比较\" class=\"headerlink\" title=\"几何求交以及两种方法比较\"></a>几何求交以及两种方法比较</h4><p><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/1/3.png\" alt=\"\"></p>\n<h2 id=\"盒子\"><a href=\"#盒子\" class=\"headerlink\" title=\"盒子\"></a>盒子</h2><p><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/1/5.png\" alt=\"\"></p>\n<h2 id=\"多边形\"><a href=\"#多边形\" class=\"headerlink\" title=\"多边形\"></a>多边形</h2><p>先与平面求交，再求这个点是不是在多边形内。<br>点在多边形内常用检测<br><a href=\"https://en.wikipedia.org/wiki/Point_in_polygon\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Point_in_polygon</a></p>\n<h2 id=\"三角形\"><a href=\"#三角形\" class=\"headerlink\" title=\"三角形\"></a>三角形</h2><p>三角形也可以采用重心的格式。这里提出了一种重心坐标下的表示方法。<br>看起来介绍的是下面这种复杂的算法<br><a href=\"https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm</a><br><a href=\"https://lisabug.github.io/2015/05/01/Ray-tracer-triangle-intersection/\" target=\"_blank\" rel=\"noopener\">https://lisabug.github.io/2015/05/01/Ray-tracer-triangle-intersection/</a></p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>显式曲面&amp;隐式曲面<br>前者可以方便的生成点，后者可以方便的检测一个点是不是在曲面上<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/1/4.png\" alt=\"\"></p>\n","categories":["Tech","MIT-6-837"],"tags":["CG"]},{"title":"assignment0 [Iterated Function Systems]","url":"https://birdy-c.github.io/2018/04/20/MOOC/MIT-6-837/assignment0/","content":"<p>这次的作业主要涉及分形算法[Chaos game版本]</p>\n<a id=\"more\"></a>\n<h1 id=\"assignment-0\"><a href=\"#assignment-0\" class=\"headerlink\" title=\"assignment 0\"></a>assignment 0</h1><p><a href=\"https://github.com/birdy-C/MIT-6-837/tree/master/Result/assignment0\" target=\"_blank\" rel=\"noopener\">https://github.com/birdy-C/MIT-6-837/tree/master/Result/assignment0</a></p>\n<p>这个assignment大概就是了解了一下分形相关的知识。之前对于分形的认知只有迭代输出一种。<br><a href=\"https://en.wikipedia.org/wiki/Sierpinski_triangle\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Sierpinski_triangle</a><br>这里实现用到的实现方式是Chaos game，觉得这种类似于元胞自动机的方式非常的神奇。</p>\n<p>主要的问题出在矩阵的运算不熟练，以及对于边界情况的处理。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>主要逻辑（不是我写的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &quot;lots&quot; of random points (x0, y0)</span><br><span class=\"line\">    for k=0 to num_iters </span><br><span class=\"line\">        pick a random transform fi</span><br><span class=\"line\">        (xk+1, yk+1) = fi(xk, yk)</span><br><span class=\"line\">    display a dot at (xk, yk)</span><br></pre></td></tr></table></figure>\n<p>然后输入<br>这是那个sierpinski_triangle的，虽然不是很懂为什么别人加的三角形都是等边三角形</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">0.33</span><br><span class=\"line\">0.500000 0.000000 0.000000 </span><br><span class=\"line\">0.000000 0.500000 0.000000 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.33 </span><br><span class=\"line\">0.500000 0.000000 0.500000 </span><br><span class=\"line\">0.000000 0.500000 0.000000 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.34 </span><br><span class=\"line\">0.500000 0.000000 0.000000 </span><br><span class=\"line\">0.000000 0.500000 0.500000 </span><br><span class=\"line\">0.000000 0.000000 1.000000</span><br></pre></td></tr></table></figure>\n<p>所以大概思路就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &quot;lots&quot; of random points (x0, y0)//x0 y0在[0,1]之间</span><br><span class=\"line\">    //生成齐次坐标下的矩阵N</span><br><span class=\"line\">    for k=0 to num_iters </span><br><span class=\"line\">        pick a random transform fi</span><br><span class=\"line\">        (xk+1, yk+1) = fi(xk, yk)//随机选择一个矩阵，然后用N*M继续下一次迭代</span><br><span class=\"line\">    display a dot at (xk, yk)//齐次坐标转到正常坐标</span><br></pre></td></tr></table></figure>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><p>写暂时不写了 码一个思路</p>\n<h3 id=\"figure-out-the-probabilities\"><a href=\"#figure-out-the-probabilities\" class=\"headerlink\" title=\"figure out the probabilities\"></a>figure out the probabilities</h3><p>这个没懂啥意思<br>如果是要一个概率可视化的话，在最后统计的时候，现在的方法是把白格子染成黑色，如果变为记录落到这个点几次的话，或者给GRB分量减掉一个定值，就理论上能够得到一个与概率有关的图。越黑代表概率越高。<br>如果需要具体的数值的话（我觉得这个要求有点高啊），可能和这题的离散化的思路不和……需要借助下面那个的bounding box，暂时能想到的就是落在最后的几个bounding box之中。  </p>\n<h3 id=\"determine-the-bounding-box\"><a href=\"#determine-the-bounding-box\" class=\"headerlink\" title=\"determine the bounding box\"></a>determine the bounding box</h3><p>用边界点确定。<br>比如现在带入的时候是生成[0，1]之间的随机数，那么在这里就可以直接计算0和1的边界情况。把这四个点进行所有可能的变换组合（生成一棵树）。然后依次连接。</p>\n<p>Shrinking and duplication<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Sierpinski_triangle_evolution_square.svg/512px-Sierpinski_triangle_evolution_square.svg.png\" alt=\"Shrinking and duplication\"></p>\n<p>chaos game<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b8/Tri%C3%A2ngulo_de_Sierpinski.gif/200px-Tri%C3%A2ngulo_de_Sierpinski.gif\" alt=\"chaos game\"></p>\n<p>这么一想的话就开始思考chaos game和其他连续的实现有什么区别，其实确定边界点的过程就类似于Shrinking and duplication这一种，并且图完色不会像chaos game那样有（密密麻麻的小黑点）的那种感觉。  </p>\n<ul>\n<li>chaos game取随机数会有一定的开销，Shrinking and duplication在计算过程中会随着层数的增加运算量指数上升  </li>\n<li>Shrinking and duplication这种的图肯定比chaos game好看……但或许可以说chaos game 从某种程度上反应了概率的分布。</li>\n</ul>\n<h3 id=\"change-the-color-scheme\"><a href=\"#change-the-color-scheme\" class=\"headerlink\" title=\"change the color scheme\"></a>change the color scheme</h3><p>如果是不同的bounding box内颜色不一样的话，可以尝试一下对不同的选择（也就是不同的到达树的叶结点的路径）编码，然后赋予不同的颜色。</p>\n<h3 id=\"anti-aliasing\"><a href=\"#anti-aliasing\" class=\"headerlink\" title=\"anti-aliasing\"></a>anti-aliasing</h3><p>在这里实现的时候，直接把float裁成int，可以根据具体float值影响周围的四个格子。<br>比如落在(100.5，100.5)，之前的做法是直接把它取整到(100,100),设为黑色。现在可以考虑把(100,100)(100,101)(101,100)(101,101)四个各种分别设置为(127,127,127)的灰色。如果一个格子被多个点影响，则取小的(影响大的)。  </p>\n<h3 id=\"depth-first-vs-breadth-first\"><a href=\"#depth-first-vs-breadth-first\" class=\"headerlink\" title=\"depth-first vs. breadth-first\"></a>depth-first vs. breadth-first</h3><p>BF除了能够，增加视觉体验，还有啥用吗（还非常占内存……）  </p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>最后实现之后感觉fern的分形真的神奇，因为在看这个图的时候我没想到它的迭代规律那么简单。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">0.03</span><br><span class=\"line\">0.000000 0.000000 0.500000 </span><br><span class=\"line\">0.000000 0.200000 0.000000 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.71</span><br><span class=\"line\">0.817377 0.065530 0.091311 </span><br><span class=\"line\">-0.065530 0.817377 0.232765 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.13</span><br><span class=\"line\">0.108707 -0.372816 0.445646 </span><br><span class=\"line\">0.279612 0.144943 -0.059806 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.13</span><br><span class=\"line\">-0.080250 0.385423 0.540125 </span><br><span class=\"line\">0.289067 0.107000 -0.004534 </span><br><span class=\"line\">0.000000 0.000000 1.000000</span><br></pre></td></tr></table></figure>\n<p>虽然看起来非常的复杂，但其实并没有更多的变换矩阵。  </p>\n<p>sierpinski_triangle<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/sier.png\" alt=\"这里写图片描述\"><br>3次迭代<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/3.png\" alt=\"这里写图片描述\"><br>5次迭代<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/5.png\" alt=\"这里写图片描述\"><br>10次<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/10.png\" alt=\"这里写图片描述\"><br>30次<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/30.png\" alt=\"这里写图片描述\"></p>\n","categories":["Tech","MIT-6-837"],"tags":["CG"]},{"title":"数学建模总结","url":"https://birdy-c.github.io/2018/02/18/轨迹/【数学建模】总结 - 2018.2/","content":"<blockquote>\n<p>前两天美赛结束，打完算是最后一次建模……<br>    感觉蛮神奇的，两次校赛一次国赛两次美赛，一开始也没想到会做这么久。<br>    稍微总结一下写一下自己的感受……其实也并没有很好的成绩2333（如果不是拿过一堆参赛奖早就功成身退了也不会参加那么多比赛）算不上经验。<br>    如果有不合适的见解欢迎指出。而且都是基于自己的经历，所以可能比较片面。  </p>\n</blockquote>\n<h1 id=\"关于建模：\"><a href=\"#关于建模：\" class=\"headerlink\" title=\"关于建模：\"></a>关于建模：</h1><p>数学建模，不是场景建模（X<br>感觉水了几次之后和一开始对建模的感觉还是有所变化的……<br>官方一点的除了国赛（全国大学生数学建模竞赛）美赛（COMAP）还有小美赛APMCM深圳杯啥的。<br>今年有一个什么比赛来着主办方跑路了然后奖项靠随机数取的，所以要参加比赛建议参加正规一点的……其实我觉得国赛美赛半年一次已经很伤肝了啊！（这大概就是老年人吧）<br>其实有参加一次深圳杯的想法，因为深圳杯的时间线比较长还有答辩，我感觉是一种不一样的操作……但是感觉也没这个时间了。</p>\n<p>主要讲国赛和美赛（其他我也不会咯）</p>\n<p>美赛分MCM和ICM，对数学知识的要求会有不同（但感觉这次的题(2018美赛)只有A要求比较高）。国赛和美赛很能感受到中外文化的差距。</p>\n<ul>\n<li>美国的话数据基本是全面公开的，而国内要找数据什么的会非常的困难。这就意味着国赛会比较少政策类的题目。</li>\n<li>美赛很多地方是自圆其说，国赛要求一个标准答案。蛮多专业社科什么的会参加美赛，不过参加国赛的会相对少一点。</li>\n<li>国赛在往开放性走（我对开放性的定义就是标准答案的决定因素相对较弱）。不过国赛的开放性格局依然是比较小的，比如道路规划之类，不会涉及到美赛那种，国家领导人提案，国际格局分析……不过数据都非常难找……国赛的开放我记得蛮多是靠仿真的（美赛我没好好准备……）</li>\n<li>此外语言不一样（……</li>\n</ul>\n<h2 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h2><h3 id=\"优\"><a href=\"#优\" class=\"headerlink\" title=\"优\"></a>优</h3><p>学到很多东西。<br>对于实际的能力，收获最大的可能是国赛前准备的那十几天，大概把我负责的模型过了一遍，然后三个人每天做一道题，找找资料讨论思路然后回去各自看论文，第二天总结交流这样一段时间。（然后……十天之后感觉该看的都看了不知道该看啥了……）这段时间如果说具体的能力的话应该是培养的最多的……（也发现其实有些获奖的模型……整个模型都是错的……有很多以这个比赛题目为研究方向的期刊之类……巧了也是错的……）</p>\n<p>然后建模的一个思想吧……这个我觉得是最大的一个收获，因为我其实没有什么科研经历，所以从这一点上来看那种解决问题的想法是从建模中来的……其实也很直接，就自己做过那么一两次（创世者）之后，就能比较容易的从另一个角度去理解问题。</p>\n<p>还有从队友身上学到的很多。毕竟这种比赛来自不同专业的队友看问题的角度会不太一样，了解一下不同专业的知识体系和认知对把握整个知识体系比较有帮助。</p>\n<h3 id=\"劣\"><a href=\"#劣\" class=\"headerlink\" title=\"劣\"></a>劣</h3><p>数学建模是非常重要的一项能力，但具体在一个比赛中能体现出多少我觉得目前还是存疑。<br>毕竟，一个比赛受到的限制还是蛮多的……而且自己也知道自己建的模其实具体的价值还是很低的……也就可以说，主观性比较强。如果看过学校和建模成绩的话……会发现其实985和其他学校比起来，获奖率并没有非常大的不同。</p>\n<p>对于一个没有做过科研的人我认为建模距离科研还差的很远。</p>\n<p>而且毕竟是一个可以借助各种通讯工具的比赛……建模比赛背后的产业链刚刚接触到的时候让我感觉有点不舒服，会觉得比较不公平吧hh 不过这有什么办法呢（摊手）讲道理要是有人出钱我也愿意代做（再次摊手）</p>\n<p>不过我觉得那种一堆人人手一份的资料……不看也罢orz</p>\n<p>【这一段是单纯吐槽……】还有一个无关痛痒（并且很可能不是由建模造成的）问题就是……平时写报告就没有贴代码贴运行截图的习惯……不习惯重述已经有的成型的模型也不喜欢分析实现过程……然后不管怎么说最后老师给分总会稍微看看字数吧然后就会比较惨……毕竟建模那么多天也才二十页这么一对比我觉得我七八页的报告已经不短了啊口亨！</p>\n<h1 id=\"关于队友：\"><a href=\"#关于队友：\" class=\"headerlink\" title=\"关于队友：\"></a>关于队友：</h1><p>我觉得队友聊得来比较重要吧……（大概是因为太菜了一直被嫌弃？）我好像基本每场比赛队友都不一样。</p>\n<p>这种比赛队友还是很重要的，像对我来说，我其实不是很喜欢被carry的感觉……所以我觉得队友最好是在同一水平线上，这样如果啥也不会的话也可以一起学一学。要是队友太厉害各种帮不上忙估计心情也会很down……不过建模这种情况还没遇到过毕竟建模要求的技能点蛮多的。</p>\n<p>有一些观点要是差太远会出问题，比如有人觉得应该刷好几个晚上把他做完，有人觉得正常休息就行，那就会有争执……（我的话认为最后一天刷一下就行……也有队伍轮流睡觉的……主要看队友怎么想了）</p>\n<p>不要吵架不要吵架不要吵架……文明讨论。各位都是大佬自己的想法被否定会不高兴但是一切以结果为主……不要赌气……</p>\n<p>还有不要玻璃心的……玻璃心的队友会非常影响讨论的氛围。要是帮不上忙动不动还闹个小情绪= =绝对是负分……</p>\n<p>还有，我感觉太过内向的可能会比较不适应表达想法。这个看各自的感觉吧。</p>\n<p>（然后我心态最崩的一次比赛，我和另一个队友动不动就怼起来然后另一个沉默的看着一句话都不说……（抚额</p>\n<p>综上所述，选队友的方式就是随缘……因为不真的打一次比赛很难了解这个人的风格和水平……而且基本上组完队之后不会换队友了。</p>\n<p>队友绝对是让我学到最多的……比赛期间，比赛前后的交流，等等，不一而足。</p>\n<h1 id=\"关于准备：\"><a href=\"#关于准备：\" class=\"headerlink\" title=\"关于准备：\"></a>关于准备：</h1><p>我觉得准备还是有用的。可以看看论文习惯一下这个比赛的套路。<br>这可能也就解释了之前那个985和普通学校情况差不多的问题……如果为了这个比赛为目的的话，准备是蛮有用的一点。<br>之前国赛准备的队伍的话，是每个人分模块学习，然后一起呆了十几天每天准备一道题这样。算是技能点比较全面的了（虽然队伍依然不是非常的契合）。很多学校会有专门的培训吧。</p>\n<p>具体怎么准备我也不说了……这个一写又是长篇大论了……各处的大佬也写的够多了。</p>\n<p>我有个队友用完matlab之后一直在吐槽这个不适合写代码= =<br>我倒是没啥感觉，只是觉得，确实不符合面向对象的思想……【反正也没有对象2333</p>\n<h1 id=\"关于solo：\"><a href=\"#关于solo：\" class=\"headerlink\" title=\"关于solo：\"></a>关于solo：</h1><p>这个solo我觉得看人吧，好像有些人会把solo看成一种很厉害的事情……对我来说solo怎么看都少了点乐趣而且毕竟多个人处理数据拎拎外卖聊聊天防止抑郁也好呀！<br>反正美赛solo我觉得……蛮贵的……（实诚<br>国赛这种还有名额限制的……估计老师不会让你solo吧……</p>\n<h1 id=\"经历\"><a href=\"#经历\" class=\"headerlink\" title=\"经历\"></a>经历</h1><p>待补吧我写不动了……估计也没人看到这……</p>\n<h1 id=\"印象最深的一些点\"><a href=\"#印象最深的一些点\" class=\"headerlink\" title=\"印象最深的一些点\"></a>印象最深的一些点</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>之前吐槽过很多模型是错的……最主要是眼科病床那题。<br><a href=\"http://blog.csdn.net/birdy_/article/details/78026059\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/birdy_/article/details/78026059</a><br>没提到的是，很多文章把优化定在评价指标上；修改了评价指标之后，在没有提出具体的优化的模型的情况下得出了更好的结论……（具体也懒得找了论文了有人有问题再说吧……）</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>有些意想不到的跨学科的应用。<br>17年国赛的CT成像对具体图像的离散方式，和计算机图形学中绘制的算法是一样的……</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p>第一次做数模是因为，那个小哥哥告诉我想要队里有个女生并且取了女生中户籍所在地离自己最近的一个因为感觉不会有地域沟通问题（喵喵喵？）</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>17国赛那题CT的coding量特别大。结果我还没开始写网上就传来了一份据说人手一份的代码……然后就发现一个核心函数是库里的（……还好我还没写……</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>整资料的时候看到自己永远在生死时速……</p>\n<p>17年国赛，MD5码截止在6点<br><img src=\"http://img.blog.csdn.net/20180228213205772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlyZHlf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p>18年美赛，提交截止10点<br><img src=\"http://img.blog.csdn.net/20180228213710189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlyZHlf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"><br>【捂脸<br>别学我……超时了就四天白干了……癌</p>\n","categories":["轨迹"],"tags":["杂记","数学建模"]},{"title":"GGJ","url":"https://birdy-c.github.io/2018/01/30/轨迹/GGJ/","content":"<p>第一次参加GGJ……被虐成狗吧状态大概是。</p>\n<p>unity不熟练，不熟悉游戏的开发，都是很主要的原因，而且个人可能重视程度也不是非常够，这样。</p>\n<p>国美小哥哥好厉害啊……我们的程序和策划好厉害呀……闪闪发光的那种。<br>感觉他们因为热爱而努力的样子，都超级值得我尊重啊。</p>\n<p>那么回到这个问题，我到底是不是应该走这条路。</p>\n<p>印象超级深的程序小哥哥问我会不会写shader，我：我现在学来不来得及……<br>QwQ大概这就是菜吧</p>\n<p>觉得做个技术美术也很不错……可我好像从高中戒了游戏的毒之后对于游戏一直是一种（看戏）的状态……而且在思考自己的热情是不是一开始“创造”所带来的新鲜感，而这样的感觉能不能长久的维系下去，自己又适不适合作为一个大型游戏里的一枚螺丝钉。</p>\n","categories":["轨迹"],"tags":["杂记"]},{"title":"about","url":"https://birdy-c.github.io/about/index.html","content":"<p>啊，早上好啊！~  </p>\n<p>之前博客在CSDN，慢慢整一遍吧。<br>总觉得自己水平不够，没有那种高屋建瓴的解释清楚一些概念的能力。所以现在的博客应该只是一个记录而没有什么历史价值233 如果可以的话有生之年慢慢培养这个能力好了233</p>\n","categories":[],"tags":[]},{"title":"tags","url":"https://birdy-c.github.io/tags/index.html","content":"","categories":[],"tags":[]},{"title":"categories","url":"https://birdy-c.github.io/categories/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://birdy-c.github.io/search/index.html","content":"","categories":[],"tags":[]}]
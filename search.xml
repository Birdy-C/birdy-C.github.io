[{"title":"assignment0","url":"https://birdy-c.github.io/2018/04/20/MIT-6-837/assignment0/","content":"<p>分形相关</p>\n<a id=\"more\"></a>\n<h1 id=\"assignment-0\"><a href=\"#assignment-0\" class=\"headerlink\" title=\"assignment 0\"></a>assignment 0</h1><p><a href=\"https://github.com/birdy-C/MIT-6-837/tree/master/Result/assignment0\" target=\"_blank\" rel=\"noopener\">https://github.com/birdy-C/MIT-6-837/tree/master/Result/assignment0</a></p>\n<p>这个assignment大概就是了解了一下分形相关的知识。之前对于分形的认知只有迭代输出一种 。<br><a href=\"https://en.wikipedia.org/wiki/Sierpinski_triangle\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Sierpinski_triangle</a><br>这里实现用到的实现方式是Chaos game，觉得这种类似于元胞自动机的方式非常的神奇。</p>\n<p>主要的bug出在矩阵的运算不熟练，以及对于边界情况的处理。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>主要逻辑（不是我写的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &quot;lots&quot; of random points (x0, y0)</span><br><span class=\"line\">    for k=0 to num_iters </span><br><span class=\"line\">        pick a random transform fi</span><br><span class=\"line\">        (xk+1, yk+1) = fi(xk, yk)</span><br><span class=\"line\">    display a dot at (xk, yk)</span><br></pre></td></tr></table></figure>\n<p>然后输入<br>这是那个sierpinski_triangle的，虽然不是很懂为什么别人加的三角形都是等边三角形</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3</span><br><span class=\"line\">0.33</span><br><span class=\"line\">0.500000 0.000000 0.000000 </span><br><span class=\"line\">0.000000 0.500000 0.000000 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.33 </span><br><span class=\"line\">0.500000 0.000000 0.500000 </span><br><span class=\"line\">0.000000 0.500000 0.000000 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.34 </span><br><span class=\"line\">0.500000 0.000000 0.000000 </span><br><span class=\"line\">0.000000 0.500000 0.500000 </span><br><span class=\"line\">0.000000 0.000000 1.000000</span><br></pre></td></tr></table></figure>\n<p>所以大概思路就是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for &quot;lots&quot; of random points (x0, y0)//x0 y0在[0,1]之间</span><br><span class=\"line\">    //生成齐次坐标下的矩阵N</span><br><span class=\"line\">    for k=0 to num_iters </span><br><span class=\"line\">        pick a random transform fi</span><br><span class=\"line\">        (xk+1, yk+1) = fi(xk, yk)//随机选择一个矩阵，然后用N*M继续下一次迭代</span><br><span class=\"line\">    display a dot at (xk, yk)//齐次坐标转到正常坐标</span><br></pre></td></tr></table></figure>\n<h2 id=\"More\"><a href=\"#More\" class=\"headerlink\" title=\"More\"></a>More</h2><p>写暂时不写了 码一个思路</p>\n<h3 id=\"figure-out-the-probabilities\"><a href=\"#figure-out-the-probabilities\" class=\"headerlink\" title=\"figure out the probabilities\"></a>figure out the probabilities</h3><p>这个没懂啥意思<br>如果是要一个概率可视化的话，在最后统计的时候，现在的方法是把白格子染成黑色，如果变为记录落到这个点几次的话，或者给GRB分量减掉一个定值，就理论上能够得到一个与概率有关的图。越黑代表概率越高。<br>如果需要具体的数值的话（我觉得这个要求有点高啊），可能和这题的离散化的思路不和……需要借助下面那个的bounding box，暂时能想到的就是落在最后的几个bounding box之中。</p>\n<h3 id=\"determine-the-bounding-box\"><a href=\"#determine-the-bounding-box\" class=\"headerlink\" title=\"determine the bounding box\"></a>determine the bounding box</h3><p>用边界点确定。<br>比如现在带入的时候是生成[0，1]之间的随机数，那么在这里就可以直接计算0和1的边界情况。把这四个点进行所有可能的变换组合（生成一棵树）。然后依次连接。</p>\n<p>Shrinking and duplication<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Sierpinski_triangle_evolution_square.svg/512px-Sierpinski_triangle_evolution_square.svg.png\" alt=\"Shrinking and duplication\"></p>\n<p>chaos game<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b8/Tri%C3%A2ngulo_de_Sierpinski.gif/200px-Tri%C3%A2ngulo_de_Sierpinski.gif\" alt=\"chaos game\"></p>\n<p>这么一想的话就开始思考chaos game和其他连续的实现有什么区别，其实确定边界点的过程就类似于Shrinking and duplication这一种，并且图完色不会像chaos game那样有（密密麻麻的小黑点）的那种感觉。</p>\n<ul>\n<li>chaos game取随机数会有一定的开销，Shrinking and duplication在计算过程中会随着层数的增加运算量指数上升</li>\n<li>Shrinking and duplication这种的图肯定比chaos game好看……但或许可以说chaos game 从某种程度上反应了概率的分布。</li>\n</ul>\n<h3 id=\"change-the-color-scheme\"><a href=\"#change-the-color-scheme\" class=\"headerlink\" title=\"change the color scheme\"></a>change the color scheme</h3><p>如果是不同的bounding box内颜色不一样的话，可以尝试一下对不同的选择（也就是不同的到达树的叶结点的路径）编码，然后赋予不同的颜色。</p>\n<h3 id=\"anti-aliasing\"><a href=\"#anti-aliasing\" class=\"headerlink\" title=\"anti-aliasing\"></a>anti-aliasing</h3><p>在这里实现的时候，直接把float裁成int，可以根据具体float值影响周围的四个格子。<br>比如落在(100.5，100.5)，之前的做法是直接把它取整到(100,100),设为黑色。现在可以考虑把(100,100)(100,101)(101,100)(101,101)四个各种分别设置为(127,127,127)的灰色。如果一个格子被多个点影响，则取小的(影响大的)。</p>\n<h3 id=\"depth-first-vs-breadth-first\"><a href=\"#depth-first-vs-breadth-first\" class=\"headerlink\" title=\"depth-first vs. breadth-first\"></a>depth-first vs. breadth-first</h3><p>BF除了能够，增加视觉体验，还有啥用吗（还非常占内存……）</p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p>最后实现之后感觉fern的分形真的神奇，因为在看这个图的时候我没想到它的迭代规律那么简单。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">0.03</span><br><span class=\"line\">0.000000 0.000000 0.500000 </span><br><span class=\"line\">0.000000 0.200000 0.000000 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.71</span><br><span class=\"line\">0.817377 0.065530 0.091311 </span><br><span class=\"line\">-0.065530 0.817377 0.232765 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.13</span><br><span class=\"line\">0.108707 -0.372816 0.445646 </span><br><span class=\"line\">0.279612 0.144943 -0.059806 </span><br><span class=\"line\">0.000000 0.000000 1.000000 </span><br><span class=\"line\">0.13</span><br><span class=\"line\">-0.080250 0.385423 0.540125 </span><br><span class=\"line\">0.289067 0.107000 -0.004534 </span><br><span class=\"line\">0.000000 0.000000 1.000000</span><br></pre></td></tr></table></figure>\n<p>虽然看起来非常的复杂，但其实并没有更多的变换矩阵。</p>\n<p>sierpinski_triangle<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/sier.png\" alt=\"这里写图片描述\"><br>3次迭代<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/3.png\" alt=\"这里写图片描述\"><br>5次迭代<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/5.png\" alt=\"这里写图片描述\"><br>10次<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/10.png\" alt=\"这里写图片描述\"><br>30次<br><img src=\"https://raw.githubusercontent.com/birdy-C/pic/master/MIT-6-837/0/30.png\" alt=\"这里写图片描述\"></p>\n","categories":["Tech","MIT-6-837"],"tags":["CG"]},{"title":"testEn","url":"https://birdy-c.github.io/2018/04/20/en/testEn/","content":"","categories":[],"tags":[]},{"title":"musictest","url":"https://birdy-c.github.io/2018/04/18/zh-CN/musictest/","content":"<p>测个音乐</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=544324831&auto=1&height=66\"></iframe>","categories":[],"tags":[]},{"title":"数学建模总结","url":"https://birdy-c.github.io/2018/02/18/zh-CN/【数学建模】总结 - 2018.2/","content":"<blockquote>\n<p>前两天美赛结束，打完算是最后一次建模……<br>    感觉蛮神奇的，两次校赛一次国赛两次美赛，一开始也没想到会做这么久。<br>    稍微总结一下写一下自己的感受……其实也并没有很好的成绩2333（如果不是拿过一堆参赛奖早就功成身退了也不会参加那么多比赛）算不上经验。<br>    如果有不合适的见解欢迎指出。而且都是基于自己的经历，所以可能比较片面。</p>\n</blockquote>\n<h1 id=\"关于建模：\"><a href=\"#关于建模：\" class=\"headerlink\" title=\"关于建模：\"></a>关于建模：</h1><p>数学建模，不是场景建模（X<br>感觉水了几次之后和一开始对建模的感觉还是有所变化的……<br>官方一点的除了国赛（全国大学生数学建模竞赛）美赛（COMAP）还有小美赛APMCM深圳杯啥的。<br>今年有一个什么比赛来着主办方跑路了然后奖项靠随机数取的，所以要参加比赛建议参加正规一点的……其实我觉得国赛美赛半年一次已经很伤肝了啊！（这大概就是老年人吧）<br>其实有参加一次深圳杯的想法，因为深圳杯的时间线比较长还有答辩，我感觉是一种不一样的操作……但是感觉也没这个时间了。</p>\n<p>主要讲国赛和美赛（其他我也不会咯）</p>\n<p>美赛分MCM和ICM，对数学知识的要求会有不同（但感觉这次的题(2018美赛)只有A要求比较高）。国赛和美赛很能感受到中外文化的差距。</p>\n<ul>\n<li>美国的话数据基本是全面公开的，而国内要找数据什么的会非常的困难。这就意味着国赛会比较少政策类的题目。</li>\n<li>美赛很多地方是自圆其说，国赛要求一个标准答案。蛮多专业社科什么的会参加美赛，不过参加国赛的会相对少一点。</li>\n<li>国赛在往开放性走（我对开放性的定义就是标准答案的决定因素相对较弱）。不过国赛的开放性格局依然是比较小的，比如道路规划之类，不会涉及到美赛那种，国家领导人提案，国际格局分析……不过数据都非常难找……国赛的开放我记得蛮多是靠仿真的（美赛我没好好准备……）</li>\n<li>此外语言不一样（……</li>\n</ul>\n<h2 id=\"评价\"><a href=\"#评价\" class=\"headerlink\" title=\"评价\"></a>评价</h2><h3 id=\"优\"><a href=\"#优\" class=\"headerlink\" title=\"优\"></a>优</h3><p>学到很多东西。<br>对于实际的能力，收获最大的可能是国赛前准备的那十几天，大概把我负责的模型过了一遍，然后三个人每天做一道题，找找资料讨论思路然后回去各自看论文，第二天总结交流这样一段时间。（然后……十天之后感觉该看的都看了不知道该看啥了……）这段时间如果说具体的能力的话应该是培养的最多的……（也发现其实有些获奖的模型……整个模型都是错的……有很多以这个比赛题目为研究方向的期刊之类……巧了也是错的……）</p>\n<p>然后建模的一个思想吧……这个我觉得是最大的一个收获，因为我其实没有什么科研经历，所以从这一点上来看那种解决问题的想法是从建模中来的……其实也很直接，就自己做过那么一两次（创世者）之后，就能比较容易的从另一个角度去理解问题。</p>\n<p>还有从队友身上学到的很多。毕竟这种比赛来自不同专业的队友看问题的角度会不太一样，了解一下不同专业的知识体系和认知对把握整个知识体系比较有帮助。</p>\n<h3 id=\"劣\"><a href=\"#劣\" class=\"headerlink\" title=\"劣\"></a>劣</h3><p>数学建模是非常重要的一项能力，但具体在一个比赛中能体现出多少我觉得目前还是存疑。<br>毕竟，一个比赛受到的限制还是蛮多的……而且自己也知道自己建的模其实具体的价值还是很低的……也就可以说，主观性比较强。如果看过学校和建模成绩的话……会发现其实985和其他学校比起来，获奖率并没有非常大的不同。</p>\n<p>对于一个没有做过科研的人我认为建模距离科研还差的很远。</p>\n<p>而且毕竟是一个可以借助各种通讯工具的比赛……建模比赛背后的产业链刚刚接触到的时候让我感觉有点不舒服，会觉得比较不公平吧hh 不过这有什么办法呢（摊手）讲道理要是有人出钱我也愿意代做（再次摊手）</p>\n<p>不过我觉得那种一堆人人手一份的资料……不看也罢orz</p>\n<p>【这一段是单纯吐槽……】还有一个无关痛痒（并且很可能不是由建模造成的）问题就是……平时写报告就没有贴代码贴运行截图的习惯……不习惯重述已经有的成型的模型也不喜欢分析实现过程……然后不管怎么说最后老师给分总会稍微看看字数吧然后就会比较惨……毕竟建模那么多天也才二十页这么一对比我觉得我七八页的报告已经不短了啊口亨！</p>\n<h1 id=\"关于队友：\"><a href=\"#关于队友：\" class=\"headerlink\" title=\"关于队友：\"></a>关于队友：</h1><p>我觉得队友聊得来比较重要吧……（大概是因为太菜了一直被嫌弃？）我好像基本每场比赛队友都不一样。</p>\n<p>这种比赛队友还是很重要的，像对我来说，我其实不是很喜欢被carry的感觉……所以我觉得队友最好是在同一水平线上，这样如果啥也不会的话也可以一起学一学。要是队友太厉害各种帮不上忙估计心情也会很down……不过建模这种情况还没遇到过毕竟建模要求的技能点蛮多的。</p>\n<p>有一些观点要是差太远会出问题，比如有人觉得应该刷好几个晚上把他做完，有人觉得正常休息就行，那就会有争执……（我的话认为最后一天刷一下就行……也有队伍轮流睡觉的……主要看队友怎么想了）</p>\n<p>不要吵架不要吵架不要吵架……文明讨论。各位都是大佬自己的想法被否定会不高兴但是一切以结果为主……不要赌气……</p>\n<p>还有不要玻璃心的……玻璃心的队友会非常影响讨论的氛围。要是帮不上忙动不动还闹个小情绪= =绝对是负分……</p>\n<p>还有，我感觉太过内向的可能会比较不适应表达想法。这个看各自的感觉吧。</p>\n<p>（然后我心态最崩的一次比赛，我和另一个队友动不动就怼起来然后另一个沉默的看着一句话都不说……（抚额</p>\n<p>综上所述，选队友的方式就是随缘……因为不真的打一次比赛很难了解这个人的风格和水平……而且基本上组完队之后不会换队友了。</p>\n<p>队友绝对是让我学到最多的……比赛期间，比赛前后的交流，等等，不一而足。</p>\n<h1 id=\"关于准备：\"><a href=\"#关于准备：\" class=\"headerlink\" title=\"关于准备：\"></a>关于准备：</h1><p>我觉得准备还是有用的。可以看看论文习惯一下这个比赛的套路。<br>这可能也就解释了之前那个985和普通学校情况差不多的问题……如果为了这个比赛为目的的话，准备是蛮有用的一点。<br>之前国赛准备的队伍的话，是每个人分模块学习，然后一起呆了十几天每天准备一道题这样。算是技能点比较全面的了（虽然队伍依然不是非常的契合）。很多学校会有专门的培训吧。</p>\n<p>具体怎么准备我也不说了……这个一写又是长篇大论了……各处的大佬也写的够多了。</p>\n<p>我有个队友用完matlab之后一直在吐槽这个不适合写代码= =<br>我倒是没啥感觉，只是觉得，确实不符合面向对象的思想……【反正也没有对象2333</p>\n<h1 id=\"关于solo：\"><a href=\"#关于solo：\" class=\"headerlink\" title=\"关于solo：\"></a>关于solo：</h1><p>这个solo我觉得看人吧，好像有些人会把solo看成一种很厉害的事情……对我来说solo怎么看都少了点乐趣而且毕竟多个人处理数据拎拎外卖聊聊天防止抑郁也好呀！<br>反正美赛solo我觉得……蛮贵的……（实诚<br>国赛这种还有名额限制的……估计老师不会让你solo吧……</p>\n<h1 id=\"经历\"><a href=\"#经历\" class=\"headerlink\" title=\"经历\"></a>经历</h1><p>待补吧我写不动了……估计也没人看到这……</p>\n<h1 id=\"印象最深的一些点\"><a href=\"#印象最深的一些点\" class=\"headerlink\" title=\"印象最深的一些点\"></a>印象最深的一些点</h1><h2 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h2><p>之前吐槽过很多模型是错的……最主要是眼科病床那题。<br><a href=\"http://blog.csdn.net/birdy_/article/details/78026059\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/birdy_/article/details/78026059</a><br>没提到的是，很多文章把优化定在评价指标上；修改了评价指标之后，在没有提出具体的优化的模型的情况下得出了更好的结论……（具体也懒得找了论文了有人有问题再说吧……）</p>\n<h2 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h2><p>有些意想不到的跨学科的应用。<br>17年国赛的CT成像对具体图像的离散方式，和计算机图形学中绘制的算法是一样的……</p>\n<h2 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h2><p>第一次做数模是因为，那个小哥哥告诉我想要队里有个女生并且取了女生中户籍所在地离自己最近的一个因为感觉不会有地域沟通问题（喵喵喵？）</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h2><p>17国赛那题CT的coding量特别大。结果我还没开始写网上就传来了一份据说人手一份的代码……然后就发现一个核心函数是库里的（……还好我还没写……</p>\n<h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h2><p>整资料的时候看到自己永远在生死时速……</p>\n<p>17年国赛，MD5码截止在6点<br><img src=\"http://img.blog.csdn.net/20180228213205772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlyZHlf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<p>18年美赛，提交截止10点<br><img src=\"http://img.blog.csdn.net/20180228213710189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmlyZHlf/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"><br>【捂脸<br>别学我……超时了就四天白干了……癌</p>\n","categories":["轨迹"],"tags":["数学建模"]},{"title":"about","url":"https://birdy-c.github.io/about/index.html","content":"<p>早上好啊！~<br>我只是测一下这个功能能不能用</p>\n","categories":[],"tags":[]},{"title":"categories","url":"https://birdy-c.github.io/categories/index.html","content":"","categories":[],"tags":[]},{"title":"tags","url":"https://birdy-c.github.io/tags/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"https://birdy-c.github.io/search/index.html","content":"","categories":[],"tags":[]}]